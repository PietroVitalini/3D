<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sketchfab 3D Configurator — Single‑Model v12</title>
  <style>
    :root{ --bg:#070b14; --panel:#0d1426; --panel-2:#0b1120; --text:#e8ecf6; --muted:#9aa5b3; --accent:#7dd3fc; --border:#1a2444 }
    *{box-sizing:border-box}
    html,body{height:100%; overflow:hidden}
    body{margin:0;background:radial-gradient(1200px 800px at 15% -10%, rgba(96,165,250,.12), transparent),
                     radial-gradient(1200px 800px at 110% 110%, rgba(125,211,252,.10), transparent),
                     var(--bg);color:var(--text);font:15px/1.5 system-ui, Segoe UI, Roboto, Helvetica, Arial}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:12px;height:100vh}
    .panel{height:100vh;overflow-y:auto;padding:20px 16px 24px;background:linear-gradient(180deg,var(--panel),var(--panel-2));border-left:1px solid var(--border)}
    .panel h1{margin:0 0 10px;font-size:18px;letter-spacing:.2px}
    .group{border:1px solid var(--border);border-radius:16px;padding:12px 12px 14px;margin:12px 0;background:#0b1326}
    .group h2{font-size:13px;color:var(--muted);margin:0 0 10px;font-weight:600;letter-spacing:.2px}
    .row{display:flex;gap:10px;align-items:center;margin:12px 0}
    label{min-width:92px;color:var(--muted)}
    input[type="file"]{width:100%}
    textarea#prompt{width:100%;display:block;resize:none;min-height:100px;border:1px solid var(--border);border-radius:12px;background:#0a1222;color:var(--text);padding:12px;outline:none;overflow:auto;scrollbar-width:none;-ms-overflow-style:none}
    textarea#prompt::-webkit-scrollbar{width:0;height:0}
    button{padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:#0a1222;color:var(--text);cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .hint{color:var(--muted);font-size:12px;margin-top:6px}
    .viewer{height:100vh}
    iframe{width:100%;height:100%;border:0;border-left:1px solid var(--border);background:transparent}

    /* Minimal color box that opens native palette on click */
    input[type="color"].colorBox{
      -webkit-appearance: none; appearance: none;
      border:1px solid var(--border); border-radius:6px; width:48px; height:28px; padding:0; background:#ffffff; cursor:pointer;
    }
    input[type="color"].colorBox::-webkit-color-swatch-wrapper{ padding:0 }
    input[type="color"].colorBox::-webkit-color-swatch{ border:none; border-radius:6px }
    .disabled{opacity:.45; pointer-events:none}
  </style>
</head>
<body>
  <!-- CONFIG: edit materials here (model UID is hard‑wired in client.init()) -->

  <div class="wrap">
    <div class="panel">
      <h1>3D Configurator</h1>

      <div class="group">
        <h2>Describe your design…</h2>
        <div class="row" style="display:block">
          <textarea id="prompt" rows="5" placeholder="Describe your ideal design in natural language (e.g., minimal geometric pattern in navy and white, subtle fabric texture)…"></textarea>
        </div>
        <div class="row" style="gap:8px">
          <button id="genBtn">Generate</button>
          <button id="prevBtn" disabled>←</button>
          <button id="nextBtn" disabled>→</button>
          <span id="genStatus" class="hint" style="margin-left:auto"></span>
        </div>
        <div class="hint">This sends your prompt to the backend, generates an image (base: white texture), and applies it as the material texture. Use arrows to revisit earlier designs.</div>
      </div>

      <div class="group">
        <h2>Colors</h2>
        <div class="row">
          <label>Contrasto</label>
          <input id="c1Input" class="colorBox" type="color" value="#ffffff" />
        </div>
        <div class="row">
          <label>Zipper</label>
          <input id="c2Input" class="colorBox" type="color" value="#ffffff" />
        </div>
        <div class="hint">Click the white box to open the native palette. Picking a color clears texture on that material.</div>
      </div>
    </div>

    <div class="viewer">
      <iframe id="api-frame" allow="autoplay; fullscreen; xr-spatial-tracking" xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share src="about:blank"></iframe>
    </div>
  </div>

  <script src="https://static.sketchfab.com/api/sketchfab-viewer-1.12.1.js"></script>
  <script>
    // ====== CONFIG (materials only) ======
    const API_BASE         = 'https://google2.faster-551.workers.dev'; // backend base URL (basic, no upscaler)
    const BASE_IMAGE_URL   = 'https://raw.githubusercontent.com/PietroVitalini/vitalini-designer/refs/heads/main/assets/models/VP9655Bianca5.png';
    // Pre‑prompt: baked-in guidance appended before the user's prompt.
    // Edit this string to steer the generator. Keep it descriptive (no "You are" system language).
    const PREPROMPT        = 'Create Image texture, keep 1:1 shape and size. each part's design should be self contained, keep in mind that the final product won't be as clear as the 2d reppresentation. User design request: ';

    const DESIGN_MATERIAL  = 'Giacca1_FRONT_2563';          // texture target
    const COLOR1_MATERIAL  = 'Contrasto_FRONT_2545';        // Color 1
    const COLOR2_MATERIAL  = 'Zipper__Velcro_FRONT_2559';                            // Color 2 (set to enable)
    // ====== /CONFIG ======

    // DOM
    const iframe = document.getElementById('api-frame');
    const promptEl = document.getElementById('prompt');
    const genBtn = document.getElementById('genBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const statusEl = document.getElementById('genStatus');
    const c1Input  = document.getElementById('c1Input');
    const c2Input  = document.getElementById('c2Input');

    // State
    let api = null;
    const materialsByName = new Map();
    const history = []; // { id, prompt, dataURL }
    let historyIndex = -1;

    // Utils
    const norm = s => (s||'').trim().toLowerCase();
    function findMaterial(name){
      if(!name) return null;
      const exact = materialsByName.get(name); if(exact) return exact;
      const lname = norm(name);
      for(const [k,v] of materialsByName){ if(norm(k)===lname) return v; }
      for(const [k,v] of materialsByName){ if(norm(k).includes(lname)) return v; }
      return null;
    }
    function hexToRGBNorm(hex){ const h = hex.replace('#',''); const i = parseInt(h,16); return [((i>>16)&255)/255, ((i>>8)&255)/255, (i&255)/255]; }
    function rgbNormToHex(arr){ const toHex = v => ('0'+Math.max(0,Math.min(255,Math.round(v*255))).toString(16)).slice(-2); return `#${toHex(arr[0]||0)}${toHex(arr[1]||0)}${toHex(arr[2]||0)}`; }
    function baseColorChannel(mat){ const ch = mat.channels||{}; return ch.AlbedoPBR?'AlbedoPBR': ch.DiffusePBR?'DiffusePBR': ch.DiffuseColor?'DiffuseColor': ch.BaseColor?'BaseColor': ch.AlbedoColor?'AlbedoColor':'AlbedoPBR'; }

    // Viewer init
    (function initViewer(){
      const client = new Sketchfab('1.12.1', iframe);
      client.init('eea360f7606149deaf75345b1df3f519', {
        autostart: 1, preload: 1, dnt: 1, camera: 0, transparent: 1, ui_controls: 1,
        ui_infos: 0, ui_help: 0, ui_settings: 0, ui_inspector: 0, ui_ar: 0, ui_vr: 0, ui_annotations: 0, ui_animations: 0, ui_stop: 0,
        ui_watermark: 0, ui_watermark_link: 0,
        success: function(apiHandle){
          api = apiHandle; api.start();
          api.addEventListener('viewerready', function(){
            if(api.setBackground){ api.setBackground({ transparent:true, color:[0,0,0,0] }, function(){}); }
            api.getMaterialList(function(err, mats){
              if(err){ console.warn('getMaterialList error', err); return; }
              materialsByName.clear(); mats.forEach(m=> materialsByName.set(m.name, m));
              setupColor(COLOR1_MATERIAL, c1Input);
              if(COLOR2_MATERIAL){ setupColor(COLOR2_MATERIAL, c2Input); } else { c2Input.classList.add('disabled'); c2Input.disabled = true; }
            });
          });
        },
        error: function(){ console.error('Sketchfab viewer failed to init'); }
      });
    })();

    function setupColor(matName, inputEl){
      const mat = findMaterial(matName);
      if(!mat){ inputEl.classList.add('disabled'); inputEl.disabled = true; return; }
      inputEl.disabled = false;

      // init with current material color if present
      const chName = baseColorChannel(mat);
      const ch = (mat.channels||{})[chName] || {};
      inputEl.value = Array.isArray(ch.color) ? rgbNormToHex(ch.color) : '#ffffff';

      const onPick = ()=> applyColor(matName, inputEl.value);
      inputEl.addEventListener('input', onPick);
      inputEl.addEventListener('change', onPick);
    }

    // Apply solid color (remove texture) — full material update for reliability
    function applyColor(matName, hex){
      const mat = findMaterial(matName); if(!api || !mat) return;
      const channel = baseColorChannel(mat);
      const rgb = hexToRGBNorm(hex);
      mat.channels = Object.assign({}, mat.channels);
      const ch = Object.assign({}, mat.channels[channel]||{});
      ch.enable = true; ch.factor = ch.factor ?? 1; ch.color = rgb; if('texture' in ch) delete ch.texture;
      mat.channels[channel] = ch;
      api.setMaterial(mat, function(err){ if(err) console.warn('setMaterial color error', err); });
    }

    // ====== DESIGN: Prompt → Worker → texture ======
    async function generateDesign(prompt){
      statusEl.textContent = 'Contacting backend…';
      const j = await tryStartGeneration(prompt);

      let finalUrl = null;
      if (j && (j.url || j.imageUrl)) {
        finalUrl = j.url || j.imageUrl; // direct image URL
      } else if (j && j.dataUrl) {
        const dataURL = j.dataUrl; // direct data URL
        await applyTextureFromDataURL(DESIGN_MATERIAL, dataURL);
        pushHistory({ id: j.id||crypto.randomUUID(), prompt, dataURL });
        statusEl.textContent = 'Applied';
        return;
      } else if (j && j.id) {
        statusEl.textContent = 'Generating…';
        finalUrl = await pollDesign(j.id);
      } else {
        throw new Error('Unexpected backend response');
      }

      const dataURL = await fetchAsDataURL(finalUrl);
      await applyTextureFromDataURL(DESIGN_MATERIAL, dataURL);
      pushHistory({ id: j.id||crypto.randomUUID(), prompt, dataURL });
      statusEl.textContent = 'Applied';
    }

    // Robust starter: tries multiple common endpoints & methods (POST JSON, then GET with query)
    async function tryStartGeneration(prompt){
      // Align with Worker contract: POST multipart/form-data to /api/generate-gemini
      // Fields: prompt, size (optional), user_id (optional), image (required)
      // Response: { data: [ { b64_json } ] }
      // 1) Fetch base image bytes
      const baseResp = await fetch(BASE_IMAGE_URL, { cache: 'no-store' });
      if(!baseResp.ok) throw new Error(`Failed to load base image (${baseResp.status})`);
      const baseBlob = await baseResp.blob();

      // 2) Compose form-data
      const fd = new FormData();
      const finalPrompt = PREPROMPT ? `${PREPROMPT}

${prompt}` : prompt;
      fd.append('prompt', finalPrompt);
      fd.append('size', '1024x1024');
      try {
        const uid = (localStorage.getItem('vd_user') || (()=>{ const id = 'anon-' + Math.random().toString(36).slice(2); localStorage.setItem('vd_user', id); return id; })());
        fd.append('user_id', uid);
      } catch {}
      fd.append('image', baseBlob, 'base.png');

      // 3) Call Worker (exact path)
      const resp = await fetch(`${API_BASE}/api/generate-gemini`, { method: 'POST', body: fd });
      if(!resp.ok){
        // surface server detail if present
        let detail = '';
        try { detail = await resp.text(); } catch {}
        throw new Error(`${resp.status} ${resp.statusText} ${detail}`.trim());
      }
      const data = await resp.json();
      const b64 = data?.data?.[0]?.b64_json;
      if(!b64) throw new Error('Backend OK but returned no image data');
      return { dataUrl: `data:image/png;base64,${b64}` };
    }

    async function pollDesign(id){
      const maxMs = 120000; const start = Date.now();
      while(true){
        const r = await fetch(`${API_BASE}/v1/designs/${id}`);
        if(!r.ok) throw new Error('Status check failed');
        const j = await r.json();
        if(j.status === 'ready' && j.url) return j.url;
        if(Date.now() - start > maxMs) throw new Error('Generation timeout');
        await new Promise(res=>setTimeout(res, 2000));
      }
    }

    async function fetchAsDataURL(url){
      const resp = await fetch(url, { cache:'no-store' });
      const blob = await resp.blob();
      return await new Promise((resolve)=>{ const fr = new FileReader(); fr.onload = ()=>resolve(fr.result); fr.readAsDataURL(blob); });
    }

    function pushHistory(item){
      history.push(item); historyIndex = history.length - 1; updateNavButtons();
    }

    function updateNavButtons(){
      prevBtn.disabled = historyIndex <= 0; nextBtn.disabled = historyIndex >= history.length - 1;
    }

    async function applyHistory(idx){
      const item = history[idx]; if(!item) return;
      await applyTextureFromDataURL(DESIGN_MATERIAL, item.dataURL);
      promptEl.value = item.prompt || '';
      historyIndex = idx; updateNavButtons();
    }

    // ====== Shared: apply texture from DataURL ======
    async function applyTextureFromDataURL(matName, dataURL){
      const mat = findMaterial(matName); if(!api || !mat) throw new Error('Material not available');
      return new Promise((resolve, reject)=>{
        api.addTexture(dataURL, function(err, texUid){
          if(err){ console.warn('addTexture error', err); reject(err); return; }
          const channel = baseColorChannel(mat);
          mat.channels = Object.assign({}, mat.channels);
          const ch = Object.assign({}, mat.channels[channel]||{});
          ch.enable = true; ch.factor = ch.factor ?? 1; ch.texture = { uid: texUid }; ch.color = [1,1,1];
          mat.channels[channel] = ch;
          api.setMaterial(mat, function(e){ if(e){ console.warn('setMaterial tex error', e); reject(e); } else resolve(); });
        });
      });
    }

    // ====== UI wiring for Design ======
    genBtn.addEventListener('click', async ()=>{
      const p = (promptEl.value||'').trim(); if(!p){ statusEl.textContent = 'Enter a prompt first'; return; }
      genBtn.disabled = true; prevBtn.disabled = true; nextBtn.disabled = true; statusEl.textContent = '';
      try{ await generateDesign(p); }
      catch(e){ console.error(e); statusEl.textContent = (e && e.message ? e.message : 'Error'); }
      finally{ genBtn.disabled = false; updateNavButtons(); }
    });
    prevBtn.addEventListener('click', ()=> applyHistory(Math.max(0, historyIndex-1)) );
    nextBtn.addEventListener('click', ()=> applyHistory(Math.min(history.length-1, historyIndex+1)) );

    // ====== END DESIGN SECTION ======
  </script>

  <!-- Cloudflare Worker (TypeScript) — scaffold only; fill in provider calls and deploy as a Worker.

  import { Hono } from 'hono';
  export interface Env { R2_BUCKET: R2Bucket; KV: KVNamespace; GEMINI_API_KEY: string; FAL_KEY: string; }
  const app = new Hono<{ Bindings: Env }>();

  app.post('/v1/designs', async (c) => {
    const { prompt } = await c.req.json();
    const id = crypto.randomUUID();
    // TODO: fetch base white from R2 or embed
    // TODO: call Gemini image gen with prompt (+ optional init image)
    // const pngBytes = await generateWithGemini(prompt, baseBytes, c.env.GEMINI_API_KEY);
    // await c.env.R2_BUCKET.put(`designs/${id}@gen.png`, pngBytes, { httpMetadata: { contentType: 'image/png' } });
    // const signedGen = await presignGet(c.env, `designs/${id}@gen.png`, 600);
    // await submitFalUpscale(c.env.FAL_KEY, { id, image_url: signedGen, webhook: new URL('/v1/fal-webhook', c.req.url).toString() });
    await c.env.KV.put(`design:${id}`, JSON.stringify({ id, prompt, status: 'processing' }), { expirationTtl: 3600 });
    return c.json({ id });
  });

  app.post('/v1/fal-webhook', async (c) => {
    const payload = await c.req.json();
    const id = payload.metadata?.id || payload.id;
    const upUrl = payload.images?.[0]?.url;
    const png = await fetch(upUrl).then(r=>r.arrayBuffer());
    await c.env.R2_BUCKET.put(`designs/${id}@up.png`, png, { httpMetadata: { contentType: 'image/png' } });
    await c.env.KV.put(`design:${id}`, JSON.stringify({ id, status: 'ready', key: `designs/${id}@up.png` }), { expirationTtl: 86400 });
    return c.text('ok');
  });

  app.get('/v1/designs/:id', async (c) => {
    const id = c.req.param('id');
    const meta = await c.env.KV.get(`design:${id}`, 'json');
    if(!meta) return c.json({ error: 'not_found' }, 404);
    if(meta.status !== 'ready') return c.json({ id, status: meta.status });
    const signed = await presignGet(c.env, meta.key, 300);
    return c.json({ id, status: 'ready', url: signed });
  });

  export default app;

  // helpers presignGet(), generateWithGemini(), submitFalUpscale() — implement with provider SDKs or fetch()
  -->
