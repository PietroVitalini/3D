<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sketchfab 3D Configurator — v13.7 (SwitchModel Fix)</title>
  <style>
    :root{ --bg:#070b14; --panel:#0d1426; --panel-2:#0b1120; --text:#e8ecf6; --muted:#9aa5b3; --accent:#7dd3fc; --border:#1a2444; --danger:#ef4444 }
    *{box-sizing:border-box}
    html,body{height:100%; overflow:hidden}
    body{margin:0;background:radial-gradient(1200px 800px at 15% -10%, rgba(96,165,250,.12), transparent),
                     radial-gradient(1200px 800px at 110% 110%, rgba(125,211,252,.10), transparent),
                     var(--bg);color:var(--text);font:15px/1.5 system-ui, Segoe UI, Roboto, Helvetica, Arial}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:12px;height:100vh}
    .panel{height:100vh;overflow-y:auto;padding:20px 16px 24px;background:linear-gradient(180deg,var(--panel),var(--panel-2));border-left:1px solid var(--border)}
    .panel h1{margin:0 0 10px;font-size:18px;letter-spacing:.2px}
    .group{border:1px solid var(--border);border-radius:16px;padding:12px 12px 14px;margin:12px 0;background:#0b1326}
    .group h2{font-size:13px;color:var(--muted);margin:0 0 10px;font-weight:600;letter-spacing:.2px}
    .row{display:flex;gap:10px;align-items:center;margin:12px 0;flex-wrap:wrap}
    label{min-width:92px;color:var(--muted)}
    select, input[type="text"], input[type="email"], textarea{width:100%}
    textarea#prompt{width:100%;display:block;resize:none;min-height:100px;border:1px solid var(--border);border-radius:12px;background:#0a1222;color:var(--text);padding:12px;outline:none;overflow:auto;scrollbar-width:none;-ms-overflow-style:none}
    textarea#prompt::-webkit-scrollbar{width:0;height:0}
    button{padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:#0a1222;color:var(--text);cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .hint{color:var(--muted);font-size:12px;margin-top:6px}
    .viewer{height:100vh}
    iframe{width:100%;height:100%;border:0;border-left:1px solid var(--border);background:transparent}

    select{appearance:none;-webkit-appearance:none;background:#0a1222;border:1px solid var(--border);border-radius:10px;color:#e8ecf6;padding:10px 36px 10px 12px;line-height:1.2;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M5 7l5 6 5-6" fill="none" stroke="%239aa5b3" stroke-width="2"/></svg>');background-repeat:no-repeat;background-position:right 10px center}
    select:focus{outline:none;box-shadow:0 0 0 2px rgba(125,211,252,.35);border-color:var(--accent)}

    #genBtn,#dlBtn{display:block;width:100%}

    .navRow{display:grid;grid-template-columns:1fr 140px 1fr;gap:8px;align-items:center}
    #prevBtn,#nextBtn{width:100%}
    .navRow button{height:44px;display:flex;align-items:center;justify-content:center;font-size:16px;border-radius:10px}
    #indexBox{width:100%;height:44px;text-align:center;border:1px solid var(--border);border-radius:10px;background:#0a1222;color:#fff;padding:0 8px;font-weight:700;letter-spacing:.3px}

    input[type="color"].colorBox{ -webkit-appearance: none; appearance: none; border:1px solid var(--border); border-radius:6px; width:48px; height:28px; padding:0; background:#ffffff; cursor:pointer; }
    input[type="color"].colorBox::-webkit-color-swatch-wrapper{ padding:0 }
    input[type="color"].colorBox::-webkit-color-swatch{ border:none; border-radius:6px }
    #colorsContainer .row{ justify-content: space-between; }
    #colorsContainer .row label{ flex:1 }

    .button--loading{ position:relative; pointer-events:none; padding-right:36px }
    .button--loading::after{ content:""; position:absolute; right:12px; top:50%; transform:translateY(-50%); width:16px; height:16px; border-radius:50%; border:2px solid var(--muted); border-top-color:transparent; animation:spin .8s linear infinite }
    @keyframes spin{ to{ transform:translateY(-50%) rotate(360deg) } }

    .error{ color:var(--danger); font-size:12px; margin-top:6px }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>3D Configurator</h1>

      <div class="group">
        <h2>Model</h2>
        <div class="row">
          <label for="typeSelect">Type</label>
          <select id="typeSelect"></select>
        </div>
        <div class="row">
          <label for="modelSelect">Model</label>
          <select id="modelSelect"></select>
        </div>
      </div>

      <div class="group">
        <h2>Describe your design…</h2>
        <div class="row" style="display:block">
          <textarea id="prompt" rows="5" placeholder="Describe your ideal design in natural language (e.g., minimal geometric pattern in navy and white, subtle fabric texture)…"></textarea>
        </div>
        <div class="row">
          <button id="genBtn">Generate</button>
        </div>
        <div class="row navRow">
          <button id="prevBtn" disabled>←</button>
          <input id="indexBox" type="text" value="0 / 0" readonly />
          <button id="nextBtn" disabled>→</button>
        </div>
        <div class="row">
          <button id="dlBtn" disabled>Download</button>
        </div>
        <div id="errorBox" class="error" style="display:none"></div>
        <div class="hint">Server history per user & model. Flicking changes 3D texture in numeric order.</div>
      </div>

      <div class="group" id="colorsGroup" style="display:none">
        <h2>Colors</h2>
        <div id="colorsContainer"></div>
        <div class="hint">Picking a color clears texture on that material.</div>
      </div>
    </div>

    <div class="viewer">
      <iframe id="api-frame" allow="autoplay; fullscreen; xr-spatial-tracking" xr-spatial-tracking execution-while-out-of-viewport execution-while-not-rendered web-share src="about:blank"></iframe>
    </div>
  </div>

  <script src="https://static.sketchfab.com/api/sketchfab-viewer-1.12.1.js"></script>
  <script>
  'use strict';
  // ================= BACKEND WIRING =================
  const API_BASE = 'https://google2.faster-551.workers.dev';
  const ENDPOINTS = Object.freeze({
    GENERATE: API_BASE + '/api/generate',
    MY_IMAGES: API_BASE + '/api/my-images',
    HEALTH: API_BASE + '/api/health',
    LEGACY: API_BASE + '/api/generate-gemini'
  });

  // ================= CATALOG =================
  const BASE_IMAGE_URL = 'https://raw.githubusercontent.com/PietroVitalini/vitalini-designer/refs/heads/main/assets/models/VP9655Bianca8.png';
  const PREPROMPT = 'Create Image texture, keep 1:1 shape and size. Each part\'s design must be self-contained. Final product is a mapped 3D garment, not a flat 2D sheet. User design request:';

  const CATALOG = {
    'Jackets': [
      {
        id: 'VP9655', name: 'VP9655', uid: 'eea360f7606149deaf75345b1df3f519',
        designMat: 'Giacca1_FRONT_2563',
        baseImage: BASE_IMAGE_URL,
        preprompt: PREPROMPT,
        colors: [
          { label: 'Contrast', material: 'Contrasto_FRONT_2545' },
          { label: 'Zipper',   material: 'Zipper__Velcro_FRONT_2559' }
        ]
      }
    ],
    'Race suits': [],
    'Ski pants':  [],
    'Vests':      []
  };

  // ================= STATE / DOM =================
  let api = null;                  // Sketchfab API handle
  let currentModel = null;         // catalog entry
  let materialsByName = new Map(); // name -> material
  let designs = [];                // [{id, seq, url, prompt, created_at}]
  let pos = -1;                    // current index into designs

  // cache for blob: URLs when using legacy base64
  const sessionBlobURLs = new Map(); // id -> blobUrl

  // DOM
  let iframe   = document.getElementById('api-frame');
  const typeSel  = document.getElementById('typeSelect');
  const modelSel = document.getElementById('modelSelect');
  const promptEl = document.getElementById('prompt');
  const genBtn   = document.getElementById('genBtn');
  const prevBtn  = document.getElementById('prevBtn');
  const nextBtn  = document.getElementById('nextBtn');
  const dlBtn    = document.getElementById('dlBtn');
  const indexBox = document.getElementById('indexBox');
  const errorBox = document.getElementById('errorBox');
  const colorsGroup = document.getElementById('colorsGroup');
  const colorsContainer = document.getElementById('colorsContainer');

  // ================= UTILITIES =================
  function fetchWithTimeout(resource, options = {}, timeoutMs = 25000){
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort('timeout'), timeoutMs);
    const opts = Object.assign({}, options, { signal: controller.signal });
    return fetch(resource, opts).finally(() => clearTimeout(id));
  }
  async function pingBackend(){
    try{ const r = await fetchWithTimeout(ENDPOINTS.HEALTH, { method:'GET', cache:'no-store' }, 6000); return r.ok; }
    catch(e){ return false; }
  }
  function showError(msg){ errorBox.textContent = msg || ''; errorBox.style.display = msg? 'block':'none'; }
  function clearError(){ showError(''); }
  const norm = s => (s||'').trim().toLowerCase();
  function baseColorChannel(mat){ const ch = mat.channels||{}; return ch.AlbedoPBR?'AlbedoPBR': ch.DiffusePBR?'DiffusePBR': ch.DiffuseColor?'DiffuseColor': ch.BaseColor?'BaseColor': ch.AlbedoColor?'AlbedoColor':'AlbedoPBR'; }
  function hexToRGBNorm(hex){ const h = String(hex||'').replace('#',''); const i = parseInt(h||'0',16); return [((i>>16)&255)/255, ((i>>8)&255)/255, (i&255)/255]; }
  function rgbNormToHex(arr){ const toHex = v => ('0'+Math.max(0,Math.min(255,Math.round((v||0)*255))).toString(16)).slice(-2); return `#${toHex(arr[0])}${toHex(arr[1])}${toHex(arr[2])}`; }
  function findMaterial(name){ if(!name) return null; const exact = materialsByName.get(name); if(exact) return exact; const lname = norm(name); for(const [k,v] of materialsByName){ if(norm(k)===lname) return v; } for(const [k,v] of materialsByName){ if(norm(k).includes(lname)) return v; } return null; }
  function getUserId(){ const KEY='vitalini_uid_v1'; let id=localStorage.getItem(KEY); if(!id){ id=crypto.randomUUID(); localStorage.setItem(KEY, id); } return id; }
  function formatIndex(){ const total = designs.length; const cur = (pos>=0 && pos<total) ? (pos+1) : 0; indexBox.value = `${cur} / ${total}`; prevBtn.disabled = !(total>1 && pos>0); nextBtn.disabled = !(total>1 && pos<total-1); dlBtn.disabled = !(total>0 && pos>=0); }

  // ================= COLORS UI =================
  function renderColors(){
    colorsContainer.innerHTML='';
    const cols = (currentModel && currentModel.colors) || [];
    if(!cols.length){ colorsGroup.style.display='none'; return; }
    colorsGroup.style.display='block';
    cols.forEach((c,i)=>{
      const row=document.createElement('div'); row.className='row';
      const lab=document.createElement('label'); lab.textContent=c.label||`Color ${i+1}`; row.appendChild(lab);
      const inp=document.createElement('input'); inp.type='color'; inp.className='colorBox'; inp.value='#ffffff'; inp.dataset.material=c.material; row.appendChild(inp);
      colorsContainer.appendChild(row);
      inp.addEventListener('input', ()=> applyColor(c.material, inp.value));
      inp.addEventListener('change', ()=> { applyColor(c.material, inp.value); try{ inp.blur(); }catch(e){} });
    });
  }

  // ================= SELECTORS =================
  function initSelectors(){
    typeSel.innerHTML = Object.keys(CATALOG).map(t=>`<option value="${t}">${t}</option>`).join('');
    typeSel.value = 'Jackets';
    populateModels();
    typeSel.addEventListener('change', populateModels);
    modelSel.addEventListener('change', ()=> switchModel(modelSel.value));
  }
  function populateModels(){
    const t = typeSel.value; const list = CATALOG[t] || [];
    modelSel.innerHTML = list.map(m=>`<option value="${m.id}">${m.name}</option>`).join('');
    if(list.length){ switchModel(list[0].id); }
    else { currentModel=null; colorsGroup.style.display='none'; indexBox.value='0 / 0'; prevBtn.disabled=nextBtn.disabled=dlBtn.disabled=true; if(iframe) iframe.src='about:blank'; materialsByName.clear(); api=null; designs=[]; pos=-1; }
  }
  function modelById(id){ const t = typeSel.value; const list = CATALOG[t]||[]; return list.find(m=>m.id===id)||null; }

  // NEW: define switchModel (fixes ReferenceError)
  async function switchModel(modelId){
    const m = modelById(modelId);
    if(!m){
      currentModel = null; designs=[]; pos=-1; formatIndex(); colorsGroup.style.display='none';
      try{ if(iframe) iframe.src='about:blank'; }catch(e){}
      return;
    }
    currentModel = m;
    renderColors();
    await initViewerForModel(m.uid);
    await reloadDesignsFromServer();
  }

  // ================= VIEWER =================
  async function initViewerForModel(uid){
    const parent = iframe ? iframe.parentNode : null; const newIframe = iframe ? iframe.cloneNode() : document.createElement('iframe');
    if(parent){ parent.replaceChild(newIframe, iframe); } iframe = newIframe; await new Promise(requestAnimationFrame);
    materialsByName.clear(); api=null;
    return new Promise((resolve)=>{
      const client = new Sketchfab('1.12.1', newIframe);
      client.init(uid, {
        autostart: 1, preload: 1, dnt: 1, camera: 0, transparent: 1, ui_controls: 1,
        ui_infos: 0, ui_help: 0, ui_settings: 0, ui_inspector: 0, ui_ar: 0, ui_vr: 0, ui_annotations: 0, ui_animations: 0, ui_stop: 0,
        ui_watermark: 0, ui_watermark_link: 0,
        success(apiHandle){
          api = apiHandle; api.start();
          api.addEventListener('viewerready', function(){
            if(api.setBackground){ api.setBackground({ transparent:true, color:[0,0,0,0] }, function(){}); }
            api.getMaterialList(function(err, mats){
              if(err){ console.warn('getMaterialList error', err); resolve(); return; }
              materialsByName.clear(); mats.forEach(m=> materialsByName.set(m.name, m));
              Array.from(colorsContainer.querySelectorAll('input[type="color"]').values()).forEach(inp=>{
                const mat=findMaterial(inp.dataset.material);
                if(mat){ const ch=(mat.channels||{})[baseColorChannel(mat)]||{}; if(Array.isArray(ch.color)){ inp.value = rgbNormToHex(ch.color); } }
              });
              resolve();
            });
          });
        },
        error(){ console.error('Sketchfab init failed'); resolve(); }
      });
    });
  }

  // ================= COLORS APPLY =================
  function applyColor(matName, hex){
    const mat=findMaterial(matName); if(!api||!mat) return; const channel=baseColorChannel(mat); const rgb=hexToRGBNorm(hex);
    mat.channels=Object.assign({}, mat.channels); const ch=Object.assign({}, mat.channels[channel]||{});
    ch.enable=true; ch.factor=ch.factor ?? 1; ch.color=rgb; if('texture' in ch) delete ch.texture; mat.channels[channel]=ch;
    api.setMaterial(mat, function(err){ if(err) console.warn('setMaterial color error', err); });
  }

  // ================= HISTORY (SERVER) =================
  async function reloadDesignsFromServer(){
    designs=[]; pos=-1; formatIndex(); clearError(); if(!currentModel) return;
    const uid = getUserId();
    try{
      const url = new URL(ENDPOINTS.MY_IMAGES); url.searchParams.set('user_id', uid); url.searchParams.set('model_id', currentModel.id);
      const res = await fetchWithTimeout(url.toString(), { cache:'no-store' }); if(!res.ok) throw new Error(`History ${res.status}`);
      const js = await res.json(); const rows = Array.isArray(js.data) ? js.data : [];
      designs = rows.map(r=> ({ id: r.id, seq: r.seq, url: r.url, prompt: r.prompt||'', created_at: r.created_at||0 }))
                    .sort((a,b)=> (a.seq||0) - (b.seq||0));
      if(designs.length){ pos = designs.length - 1; await applyDesignAt(pos, {prefetchPrev:true}); }
      formatIndex();
    } catch(e){ console.warn('reloadDesignsFromServer', e); showError('Could not load server history for this model.'); }
  }

  async function ensureTextureURL(design){
    if (!design) return null;
    if (design.url) return design.url; // R2 public asset
    // legacy: we produced a base64 → stored in blob URL in sessionBlobURLs
    return sessionBlobURLs.get(design.id) || null;
  }

  async function applyDesignAt(index, {prefetchPrev=false}={}){
    if(index<0 || index>=designs.length) return; const d = designs[index];
    const texUrl = await ensureTextureURL(d); if(!texUrl) { showError('Texture URL unavailable for this design'); return; }
    await applyTextureFromURL(currentModel.designMat, texUrl);
    pos = index; formatIndex(); clearError(); if(prefetchPrev && index>0){ ensureTextureURL(designs[index-1]).catch(()=>{}); }
  }

  // ================= GENERATION =================
  async function doGenerate(){
    const userPrompt = String((promptEl.value||'')).trim(); if(!userPrompt){ clearError(); showError('Enter a prompt first'); return; }
    if(!currentModel){ showError('Select a model first'); return; }
    const modelPre = currentModel.preprompt || PREPROMPT; const finalPrompt = `${modelPre}\n\n${userPrompt}`;
    clearError();
    const prevText = genBtn.textContent; genBtn.textContent='Generating…'; genBtn.classList.add('button--loading'); genBtn.setAttribute('aria-busy','true');
    genBtn.disabled=true; prevBtn.disabled=true; nextBtn.disabled=true;
    try{
      // Load base (1:1) image safely
      const baseUrl = currentModel.baseImage || BASE_IMAGE_URL; const baseResp = await fetchWithTimeout(baseUrl, { cache:'no-store' }); if(!baseResp.ok) throw new Error(`Failed to load base image (${baseResp.status})`);
      const baseBlob = await baseResp.blob();
      if(!(baseBlob instanceof Blob) || !baseBlob.size){ throw new Error('Base image blob is invalid'); }

      // Strict FormData composition (avoid accidental non-strings)
      const fd = new FormData();
      fd.append('prompt', String(finalPrompt));
      fd.append('size', '1024x1024');
      fd.append('user_id', String(getUserId()));
      fd.append('model_id', String(currentModel.id));
      fd.append('image', new File([baseBlob], 'base.png', { type: baseBlob.type || 'image/png' }));

      // Primary path (stores to D1/R2)
      let resp;
      try { resp = await fetchWithTimeout(ENDPOINTS.GENERATE, { method:'POST', body: fd }); }
      catch(err){ // network/CORS/timeout → try legacy
        try { resp = await fetchWithTimeout(ENDPOINTS.LEGACY, { method:'POST', body: fd }); }
        catch(e){ throw new Error('NETWORK (CORS/timeout). Could not reach backend. Ensure this frontend origin is in CORS_ALLOW_ORIGINS and the Worker domain is correct.'); }
      }

      if(!resp.ok){
        if (resp.status === 404 || resp.status === 405) {
          const legacy = await fetchWithTimeout(ENDPOINTS.LEGACY, { method:'POST', body: fd });
          if (!legacy.ok) { const tt = await legacy.text().catch(()=> ''); throw new Error(`Backend error ${legacy.status}: ${tt}`.trim()); }
          const legacyData = await legacy.json(); const b64 = legacyData?.data?.[0]?.b64_json; if(!b64) throw new Error('Legacy endpoint returned no image');
          const blob = b64ToBlob(b64, 'image/png'); const blobUrl = URL.createObjectURL(blob);
          const synthetic = { id: crypto.randomUUID(), seq: (designs.at(-1)?.seq||0) + 1, url: null, prompt: userPrompt, created_at: Date.now() };
          sessionBlobURLs.set(synthetic.id, blobUrl); designs.push(synthetic);
          await applyTextureFromURL(currentModel.designMat, blobUrl); pos = designs.length - 1; formatIndex(); return;
        }
        const t = await resp.text().catch(()=> ''); throw new Error(`Backend error ${resp.status}: ${t}`.trim());
      }

      const data = await resp.json(); const items = Array.isArray(data?.data) ? data.data : [];
      if(!items.length) throw new Error('Backend OK but returned no image');
      for (const it of items){
        const design = { id: it.id, seq: it.seq, url: it.url, prompt: userPrompt, created_at: Date.now() };
        designs.push(design);
        await applyTextureFromURL(currentModel.designMat, design.url);
        pos = designs.length - 1;
      }
      formatIndex();
    } catch(e){ console.error(e); showError((e && e.message) ? e.message : 'Error'); }
    finally { genBtn.textContent=prevText; genBtn.classList.remove('button--loading'); genBtn.removeAttribute('aria-busy'); genBtn.disabled=false; formatIndex(); }
  }

  // ================= TEXTURE APPLY (URL ONLY) =================
  function applyTextureFromURL(matName, url){
    const mat = findMaterial(matName); if(!api || !mat) return Promise.reject(new Error('Material not available'));
    if(!url || typeof url !== 'string'){ return Promise.reject(new Error('Texture URL is invalid')); }
    return new Promise((resolve,reject)=>{
      api.addTexture(url, function(err, texUid){
        if(err){ reject(err); return; }
        const chName = baseColorChannel(mat);
        mat.channels = Object.assign({}, mat.channels);
        const ch = Object.assign({}, mat.channels[chName]||{});
        ch.enable=true; ch.factor=ch.factor??1; ch.texture={uid:texUid}; ch.color=[1,1,1];
        mat.channels[chName]=ch;
        api.setMaterial(mat, function(e){ if(e) reject(e); else resolve(); });
      });
    });
  }

  // ================= NAV + DOWNLOAD =================
  prevBtn.addEventListener('click', ()=>{ if(designs.length && pos>0){ applyDesignAt(pos-1); } });
  nextBtn.addEventListener('click', ()=>{ if(designs.length && pos<designs.length-1){ applyDesignAt(pos+1); } });
  dlBtn.addEventListener('click', ()=>{
    if(!(designs.length && pos>=0)) return; const d=designs[pos];
    const direct = d.url || sessionBlobURLs.get(d.id) || null; if(!direct){ showError('Nothing to download for this design in this session'); return; }
    const a=document.createElement('a'); const name=`${currentModel?.id||'model'}_design_${d.seq||pos+1}.png`; a.href = direct; a.download = name; if(d.url) { a.target = '_blank'; a.rel='noopener'; }
    document.body.appendChild(a); a.click(); a.remove();
  });

  // ================= EVENTS & INIT =================
  genBtn.addEventListener('click', doGenerate);
  (async function init(){
    initSelectors();
    const ok = await pingBackend();
    if(!ok){ console.warn('Ping failed: check Worker domain and CORS_ALLOW_ORIGINS'); showError('Cannot reach backend. Verify CORS_ALLOW_ORIGINS includes ' + location.origin + ' and that API_BASE is correct.'); }
    selfTest();
  })();

  // ================= HELPERS / TESTS =================
  function b64ToBlob(b64, mime='application/octet-stream'){
    const bin = atob(String(b64)); const len = bin.length; const bytes = new Uint8Array(len);
    for(let i=0;i<len;i++) bytes[i]=bin.charCodeAt(i);
    return new Blob([bytes], { type: mime });
  }

  function assert(name, cond){ if(!cond){ console.warn('[test]', name, 'FAILED'); } }
  function selfTest(){
    try{
      assert('Sketchfab API loaded', typeof Sketchfab === 'function');
      assert('API endpoints are strings', Object.values(ENDPOINTS).every(v=> typeof v === 'string' && v.startsWith('http')));
      assert('PREPROMPT string', typeof PREPROMPT === 'string');
      assert('switchModel exists', typeof switchModel === 'function');
      assert('renderColors exists', typeof renderColors === 'function');
      // FormData composition test with tiny PNG
      const tinyPNG = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGMAAQAABQABDQottQAAAABJRU5ErkJggg==';
      const blob = b64ToBlob(tinyPNG, 'image/png');
      const fd = new FormData(); fd.append('prompt','x'); fd.append('size','1024x1024'); fd.append('user_id','u'); fd.append('model_id','m'); fd.append('image', new File([blob], 't.png', {type:'image/png'}));
      assert('FormData image is File', fd.get('image') instanceof File);
      assert('size format', /^\d+x\d+$/.test(fd.get('size')));
      // Colors UI mirrors catalog when a model is set
      const demoModel = (CATALOG['Jackets'] && CATALOG['Jackets'][0]) || null;
      if (demoModel) {
        currentModel = demoModel; renderColors();
        const inputs = colorsContainer.querySelectorAll('input[type="color"]').length;
        assert('color inputs reflect model.colors', inputs === (demoModel.colors || []).length);
      }
    }catch(e){ console.warn('[selfTest] exception', e); }
  }
  </script>
</body>
</html>
