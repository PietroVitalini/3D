<script src="https://static.sketchfab.com/api/sketchfab-viewer-1.12.1.js"></script>
<script>
  // ====== BACKEND WIRING (same Worker as the 2D app) ======
  const API_BASE = 'https://google2.faster-551.workers.dev';
  const ENDPOINTS = {
    GENERATE:  API_BASE + '/api/generate',
    MY_IMAGES: API_BASE + '/api/my-images',
    REGISTER:  API_BASE + '/api/register',   // (optional) if you later add an email gate
  };

  // ====== DESIGN / MODEL CONFIG ======
  const BASE_IMAGE_URL = 'https://raw.githubusercontent.com/PietroVitalini/vitalini-designer/refs/heads/main/assets/models/VP9655Bianca8.png';
  const PREPROMPT = 'Create Image texture, keep 1:1 shape and size. each parts design should be self contained, keep in mind that the final product will not be as clear as the 2d reppresentation. User design request: ';

  const CATALOG = {
    'Jackets': [
      {
        id: 'VP9655', name: 'VP9655', uid: 'eea360f7606149deaf75345b1df3f519',
        designMat: 'Giacca1_FRONT_2563',
        baseImage: BASE_IMAGE_URL,
        // preprompt: 'Override per-model prompt here if needed',
        colors: [
          { label: 'Contrast', material: 'Contrasto_FRONT_2545' },
          { label: 'Zipper',   material: 'Zipper__Velcro_FRONT_2559' }
        ]
      }
    ],
    'Race suits': [],
    'Ski pants':  [],
    'Vests':      []
  };

  // ====== STATE ======
  let api = null;                 // Sketchfab API handle
  let currentModel = null;        // currently selected model config
  let materialsByName = new Map();

  // Server-backed history (canonical). Always sorted by seq ascending.
  let serverHistory = [];         // [{id, seq, url, prompt, created_at, model_id}]
  let currentIndex = 0;           // 1-based position in serverHistory

  // DOM refs
  let iframe   = document.getElementById('api-frame');
  const typeSel  = document.getElementById('typeSelect');
  const modelSel = document.getElementById('modelSelect');
  const promptEl = document.getElementById('prompt');
  const genBtn   = document.getElementById('genBtn');
  const prevBtn  = document.getElementById('prevBtn');
  const nextBtn  = document.getElementById('nextBtn');
  const dlBtn    = document.getElementById('dlBtn');
  const indexBox = document.getElementById('indexBox');
  const errorBox = document.getElementById('errorBox');
  const colorsGroup = document.getElementById('colorsGroup');
  const colorsContainer = document.getElementById('colorsContainer');

  // ====== UTIL ======
  const USER_KEY = 'vitalini_uid_v1'; // unify with 2D app
  function getUserId(){
    let id = localStorage.getItem(USER_KEY);
    if(!id){ id = crypto.randomUUID(); localStorage.setItem(USER_KEY, id); }
    return id;
  }
  const norm = s => (s||'').trim().toLowerCase();
  function showError(msg){ if(!errorBox) return; errorBox.textContent = msg; errorBox.style.display = 'block'; }
  function clearError(){ if(!errorBox) return; errorBox.textContent = ''; errorBox.style.display = 'none'; }

  function baseColorChannel(mat){
    const ch = mat.channels||{};
    return ch.AlbedoPBR?'AlbedoPBR': ch.DiffusePBR?'DiffusePBR': ch.DiffuseColor?'DiffuseColor': ch.BaseColor?'BaseColor': ch.AlbedoColor?'AlbedoColor':'AlbedoPBR';
  }
  function hexToRGBNorm(hex){ const h = hex.replace('#',''); const i = parseInt(h,16); return [((i>>16)&255)/255, ((i>>8)&255)/255, (i&255)/255]; }
  function rgbNormToHex(arr){
    const toHex = v => ('0'+Math.max(0,Math.min(255,Math.round(v*255))).toString(16)).slice(-2);
    return `#${toHex(arr[0]||0)}${toHex(arr[1]||0)}${toHex(arr[2]||0)}`;
  }
  function findMaterial(name){
    if(!name) return null;
    const exact = materialsByName.get(name);
    if(exact) return exact;
    const lname = norm(name);
    for(const [k,v] of materialsByName){ if(norm(k)===lname) return v; }
    for(const [k,v] of materialsByName){ if(norm(k).includes(lname)) return v; }
    return null;
  }
  function buildPromptForModel(userPrompt){
    const p = (currentModel && currentModel.preprompt) || PREPROMPT;
    return [p, (userPrompt||'').trim()].filter(Boolean).join('\n\n');
  }

  async function fetchAsDataURL(url){
    const r = await fetch(url, { cache: 'no-store' });
    if(!r.ok) throw new Error(`Failed to fetch image: ${r.status}`);
    const b = await r.blob();
    return await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(b); });
  }

  // ====== VIEWER ======
  function initViewerForModel(uid){
    const parent = iframe ? iframe.parentNode : null;
    const newIframe = iframe ? iframe.cloneNode() : document.createElement('iframe');
    if(parent){ parent.replaceChild(newIframe, iframe); }
    iframe = newIframe;
    window.requestAnimationFrame(()=>{
      materialsByName = new Map(); api = null;
      const client = new Sketchfab('1.12.1', newIframe);
      client.init(uid, {
        autostart: 1, preload: 1, dnt: 1, camera: 0, transparent: 1, ui_controls: 1,
        ui_infos: 0, ui_help: 0, ui_settings: 0, ui_inspector: 0, ui_ar: 0, ui_vr: 0,
        ui_annotations: 0, ui_animations: 0, ui_stop: 0, ui_watermark: 0, ui_watermark_link: 0,
        success: function(apiHandle){
          api = apiHandle; api.start();
          api.addEventListener('viewerready', function(){
            if(api.setBackground){ api.setBackground({ transparent:true, color:[0,0,0,0] }, function(){}); }
            api.getMaterialList(async function(err, mats){
              if(err){ console.warn('getMaterialList error', err); return; }
              materialsByName.clear(); mats.forEach(m=> materialsByName.set(m.name, m));
              // Prime color pickers with live material colors
              Array.from(colorsContainer.querySelectorAll('input[type="color"]')).forEach(inp=>{
                const mat = findMaterial(inp.dataset.material);
                if(mat){ const ch = (mat.channels||{})[baseColorChannel(mat)]||{}; if(Array.isArray(ch.color)){ inp.value = rgbNormToHex(ch.color); } }
              });
              // Load server history for this model and hydrate the latest
              await reloadServerHistory();
              if(serverHistory.length){
                await applyServerIndex(serverHistory.length); // latest
              } else {
                updateNavUI(0, 0);
              }
            });
          });
        },
        error: function(){ console.error('Sketchfab init failed'); }
      });
    });
  }

  async function applyTextureFromDataURL(matName, dataURL){
    const mat = findMaterial(matName);
    if(!api || !mat) throw new Error('Material not available');
    return new Promise((resolve,reject)=>{
      api.addTexture(dataURL, function(err, texUid){
        if(err){ reject(err); return; }
        const chName = baseColorChannel(mat);
        mat.channels = Object.assign({}, mat.channels);
        const ch = Object.assign({}, mat.channels[chName]||{});
        ch.enable=true; ch.factor=ch.factor??1; ch.texture={uid:texUid}; ch.color=[1,1,1];
        mat.channels[chName]=ch;
        api.setMaterial(mat, function(e){ if(e) reject(e); else resolve(); });
      });
    });
  }
  async function applyTextureFromURL(matName, url){
    // Using DataURL avoids viewer-side CORS headaches
    const dataURL = await fetchAsDataURL(url);
    return applyTextureFromDataURL(matName, dataURL);
  }

  // ====== COLORS ======
  function applyColor(matName, hex){
    const mat = findMaterial(matName);
    if(!api || !mat) return;
    const channel = baseColorChannel(mat);
    const rgb = hexToRGBNorm(hex);
    mat.channels = Object.assign({}, mat.channels);
    const ch = Object.assign({}, mat.channels[channel]||{});
    ch.enable = true; ch.factor = ch.factor ?? 1; ch.color = rgb;
    if('texture' in ch) delete ch.texture; // color overrides texture
    mat.channels[channel] = ch;
    api.setMaterial(mat, function(err){ if(err) console.warn('setMaterial color error', err); });
  }

  // ====== MODEL SELECTORS ======
  function initSelectors(){
    typeSel.innerHTML = Object.keys(CATALOG).map(t=>`<option value="${t}">${t}</option>`).join('');
    typeSel.value = 'Jackets';
    populateModels();
    typeSel.addEventListener('change', populateModels);
    modelSel.addEventListener('change', ()=> switchModel(modelSel.value));
  }
  function populateModels(){
    const t = typeSel.value;
    const list = CATALOG[t] || [];
    modelSel.innerHTML = list.map(m=>`<option value="${m.id}">${m.name}</option>`).join('');
    if(list.length){ switchModel(list[0].id); }
    else{
      currentModel = null;
      colorsGroup.style.display='none';
      indexBox.value = '0 / 0';
      prevBtn.disabled = true; nextBtn.disabled = true; dlBtn.disabled = true;
      if (iframe) iframe.src = 'about:blank';
      materialsByName = new Map(); api = null; serverHistory = []; currentIndex = 0;
    }
  }
  function modelById(id){
    const t = typeSel.value;
    const list = (CATALOG[t]||[]);
    return list.find(m=>m.id===id)||null;
  }
  function switchModel(modelId){
    const m = modelById(modelId);
    if(!m) return;
    currentModel = m;
    renderColors();
    initViewerForModel(m.uid);
  }
  function renderColors(){
    colorsContainer.innerHTML = '';
    const cols = (currentModel && currentModel.colors) || [];
    if(!cols.length){ colorsGroup.style.display='none'; try{ if(document.activeElement?.type === 'color'){ document.activeElement.blur(); } }catch{}; return; }
    colorsGroup.style.display='block';
    cols.forEach((c,i)=>{
      const row = document.createElement('div'); row.className='row';
      const lab = document.createElement('label'); lab.textContent = c.label || `Color ${i+1}`; row.appendChild(lab);
      const inp = document.createElement('input'); inp.type='color'; inp.className='colorBox'; inp.value='#ffffff'; inp.dataset.material = c.material; row.appendChild(inp);
      colorsContainer.appendChild(row);
      inp.addEventListener('input', ()=> applyColor(c.material, inp.value));
      inp.addEventListener('change', ()=> { applyColor(c.material, inp.value); try{ inp.blur(); }catch{} });
    });
  }

  // ====== SERVER HISTORY (D1) ======
  function updateNavUI(pos, total){
    currentIndex = Math.max(0, pos);
    indexBox.value = `${total ? pos : 0} / ${total}`;
    prevBtn.disabled = !(total > 1 && pos > 1);
    nextBtn.disabled = !(total > 1 && pos < total);
    dlBtn.disabled   = !(total > 0);
  }

  async function reloadServerHistory(){
    if(!currentModel) { serverHistory=[]; updateNavUI(0,0); return; }
    const uid = getUserId();
    const qs = new URLSearchParams({
      user_id: uid,
      model_id: currentModel.id, // server filter per model
      limit: '50'
    });
    try{
      const r = await fetch(`${ENDPOINTS.MY_IMAGES}?${qs.toString()}`, { cache:'no-store' });
      if(!r.ok) throw new Error(`History load failed: ${r.status}`);
      const j = await r.json();
      const rows = Array.isArray(j.data) ? j.data : [];
      // sort seq ascending for natural numeric order
      serverHistory = rows.slice().sort((a,b)=> (a.seq||0) - (b.seq||0));
      updateNavUI(serverHistory.length, serverHistory.length);
    }catch(e){
      console.warn(e);
      serverHistory = [];
      updateNavUI(0,0);
    }
  }

  async function applyServerIndex(idx){
    if(!serverHistory.length) { updateNavUI(0,0); return; }
    const clamped = Math.max(1, Math.min(idx, serverHistory.length));
    const item = serverHistory[clamped-1];
    clearError();
    try{
      await applyTextureFromURL(currentModel.designMat, item.url);
      updateNavUI(clamped, serverHistory.length);
      // Keep prompt visible when navigating history
      if(typeof item.prompt === 'string') promptEl.value = item.prompt;
    }catch(e){
      console.error(e);
      showError('Could not load texture for this design.');
      updateNavUI(clamped, serverHistory.length);
    }
  }

  // ====== GENERATION ======
  async function generateViaWorker(finalPrompt){
    // 1) get base image (your UV layout / baked model sheet)
    const baseUrl = (currentModel && currentModel.baseImage) || BASE_IMAGE_URL;
    const baseResp = await fetch(baseUrl, { cache:'no-store' });
    if(!baseResp.ok) throw new Error(`Failed to load base image (${baseResp.status})`);
    const baseBlob = await baseResp.blob();

    // 2) call the same /api/generate as the 2D app (persist to D1+R2)
    const fd = new FormData();
    fd.append('prompt', finalPrompt);
    fd.append('size', '1024x1024');
    fd.append('user_id', getUserId());
    fd.append('model_id', currentModel.id); // saved in D1 for per-model filtering
    fd.append('image', new File([baseBlob], 'base.png', { type:'image/png' }));

    const resp = await fetch(ENDPOINTS.GENERATE, { method:'POST', body: fd });
    if(resp.status === 404) throw new Error('FALLBACK'); // worker not deployed yet
    if(!resp.ok){
      const t = await resp.text().catch(()=> '');
      throw new Error(`Generate failed: ${resp.status} ${t}`.trim());
    }
    const j = await resp.json();
    const items = Array.isArray(j.data) ? j.data : [];
    if(!items.length) throw new Error('Backend OK but returned no image data');
    // We only use the first image (count=1 server-side)
    return items[0]; // { id, seq, url, thumb_url, ... }
  }

  async function generateViaLegacy(finalPrompt){
    // Legacy endpoint: ephemeral, no persistence (your current behavior)
    const baseUrl = (currentModel && currentModel.baseImage) || BASE_IMAGE_URL;
    const baseResp = await fetch(baseUrl, { cache:'no-store' });
    if(!baseResp.ok) throw new Error(`Failed to load base image (${baseResp.status})`);
    const baseBlob = await baseResp.blob();

    const fd = new FormData();
    fd.append('prompt', finalPrompt);
    fd.append('size', '1024x1024');
    fd.append('user_id', (localStorage.getItem('vd_user')||'anon'));
    fd.append('image', baseBlob, 'base.png');

    const resp = await fetch(`${API_BASE}/api/generate-gemini`, { method:'POST', body: fd });
    if(!resp.ok){ let t=''; try{t=await resp.text();}catch(e){} throw new Error(`${resp.status} ${resp.statusText} ${t}`.trim()); }
    const data = await resp.json();
    const b64 = data?.data?.[0]?.b64_json;
    if(!b64) throw new Error('Backend OK but returned no image data');
    return { url: null, dataUrl: `data:image/png;base64,${b64}`, seq: null };
  }

  async function doGenerate(){
    const raw = (promptEl.value||'').trim();
    if(!raw){ clearError(); showError('Enter a prompt first'); return; }
    const finalPrompt = buildPromptForModel(raw);
    clearError();

    const prevText = genBtn.textContent;
    genBtn.textContent = 'Generating…';
    genBtn.classList.add('button--loading');
    genBtn.setAttribute('aria-busy', 'true');
    genBtn.disabled = true; prevBtn.disabled = true; nextBtn.disabled = true;

    try{
      let item;
      try{
        // Preferred: persisted generate → D1+R2 (+ seq)
        item = await generateViaWorker(finalPrompt); // {id, seq, url}
        // apply returned image as texture
        await applyTextureFromURL(currentModel.designMat, item.url);
        // reflect in in-memory server history immediately
        serverHistory.push({
          id: item.id, seq: item.seq, url: item.url,
          prompt: raw, created_at: Date.now(), model_id: currentModel.id
        });
        // keep ascending by seq just in case of race conditions
        serverHistory.sort((a,b)=> (a.seq||0)-(b.seq||0));
        await applyServerIndex(serverHistory.length);
      } catch(e){
        if(String(e.message) === 'FALLBACK'){
          // Legacy path (no persistence). Works like your current v13.3.
          const legacy = await generateViaLegacy(finalPrompt);
          await applyTextureFromDataURL(currentModel.designMat, legacy.dataUrl);
          // still refresh server history (in case previous items exist)
          await reloadServerHistory();
          if(serverHistory.length){ await applyServerIndex(serverHistory.length); }
        } else {
          throw e;
        }
      }
    } catch(err){
      console.error(err);
      showError(err.message || 'Error');
    } finally {
      genBtn.textContent = prevText;
      genBtn.classList.remove('button--loading');
      genBtn.removeAttribute('aria-busy');
      genBtn.disabled = false;
      updateNavUI(currentIndex || serverHistory.length, serverHistory.length);
    }
  }

  // ====== NAV + DOWNLOAD ======
  prevBtn.addEventListener('click', async ()=>{
    if(serverHistory.length > 1){
      const target = Math.max(1, (currentIndex||serverHistory.length) - 1);
      await applyServerIndex(target);
    }
  });
  nextBtn.addEventListener('click', async ()=>{
    if(serverHistory.length > 1){
      const target = Math.min(serverHistory.length, (currentIndex||1) + 1);
      await applyServerIndex(target);
    }
  });
  dlBtn.addEventListener('click', async ()=>{
    if(!serverHistory.length) return;
    const item = serverHistory[(currentIndex ? currentIndex : serverHistory.length) - 1];
    try{
      const dataURL = item.url ? await fetchAsDataURL(item.url) : null;
      if(!dataURL) throw new Error('Nothing to download for this design');
      const a = document.createElement('a');
      const name = `${currentModel?.id||'model'}_design_${item.seq||currentIndex}.png`;
      a.href = dataURL; a.download = name; document.body.appendChild(a); a.click(); a.remove();
    } catch(e){ showError(e.message||'Download failed'); }
  });

  // Close native color picker popover after picking (UX polish)
  document.addEventListener('change', function(e){
    const t = e.target;
    if (t && t.matches && t.matches('input.colorBox[type="color"]')) { try{ t.blur(); }catch{} }
  });

  // ====== BOOT ======
  genBtn.addEventListener('click', ()=>{ doGenerate(); });

  // minimal self-tests
  (function selfTest(){
    function assert(name, cond){ if(!cond){ console.warn('[selfTest]', name, 'FAILED'); } }
    try {
      assert('index format separator', '12 / 12'.includes(' / '));
      assert('getUserId stable', !!getUserId());
    } catch (e) { console.warn('[selfTest] exception', e); }
  })();

  initSelectors();
</script>
